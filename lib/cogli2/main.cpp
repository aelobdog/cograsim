/*
 * cogli1.cpp
 *
 *  Created on: 20/ott/2013
 *      Author: lorenzo
 */

#include <iostream>
#include <vector>
#include <string>

#include "Utils/Logging.h"
#include "optionparser.h"
#include "cl_arguments.h"
#include "Cogli2.h"

#define CODE_VERSION "2.0.1"

using std::string;
using std::vector;
using std::cout;
using std::endl;

const option::Descriptor usage[] = {
{UNKNOWN               , 0, "" , ""              , option::Arg::None,     "USAGE: cogli2 [options] input_1 input_2 ...\n\nOptions:" },
{HELP                  , 0, "h", "help"          , option::Arg::None,     "  --help, -h\n          Print usage and exit" },
{DIM                   , 0, "" , "dim"           , option::Arg::Required, "  --dim widthxheight\n          Set the initial window dimensions (defaults to 1024x768)" },
{BRING_IN_BOX          , 0, "b", "bring-in-box"  , option::Arg::None,     "  --bring-in-box, -b\n          Bring particles back into the box" },
{DEBUG                 , 0, "d", "debug"         , option::Arg::None,     "  --debug, -d\n          Debug mode. All primitives are rendered as wireframes"},
{TOPOLOGY              , 0, "t", "topology"      , option::Arg::Required, "  --topology, -t topology_file\n          Topology file required to open oxDNA configurations"},
{VISIBILITY_FILE       , 0, "i", "visibility"    , option::Arg::Required, "  --visibility, -i visibility_file\n          Visibility file containing a list of particles that should not appear in the box"},
{LOAD_FILE             , 0, "l", "load"          , option::Arg::Required, "  --load, -l file\n          Load a cogli1 state file"},
{SHIFT_EVERY           , 0, "s", "shift-every"   , option::Arg::Required, "  --shift-every, -s value\n          Group particles so that periodic boundary conditions are applied only to the centres of mass of the group"},
{DNA_RIBBONS           , 0, "" , "ribbons"       , option::Arg::None,     "  --ribbons\n          Export DNA strands as ribbons in povray format"},
{PATCHY_KF             , 0, "k", "kern-frenkel"  , option::Arg::None,     "  --kern-frenkel, -k\n          Export patches on patchy particles as truncated cones in povray format"},
{ONLY_POV              , 0, "o", "only-pov"      , option::Arg::None,     "  --only-pov, -o\n          Generate povray output and exit"},
{COM_CENTRE            , 0, "v", "com-centre"    , option::Arg::None,     "  --com-centre, -v\n          Centre the first configuration's centre of mass"},
{ALWAYS_CENTRE         , 0, "" , "always-centre" , option::Arg::Optional, "  --always-centre\n          Configurations are centred each time they are visualised with respect to their centre of mass (if no arguments are given) or to a specific particle/strand (if given)"},
{INERTIA  		       , 0, "I", "inertia"		 , option::Arg::None,     "  --inertia, -I\n          When centred, configurations are rotated so that their principal axes of inertia are aligned along x, y and z"},
{MM_GROOVING           , 0, "m", "mm-grooving"   , option::Arg::None,     "  --mm-grooving, -m\n          Set major/minor grooving for DNA configurations"},
{RNA		           , 0, "" , "rna"  		 , option::Arg::None,     "  --rna\n          Assume RNA strands"},
{STARR		           , 0, "" , "starr" 		 , option::Arg::Optional, "  --starr[=2]\n          Assume Starr configurations. The optional parameter changes the size of the dimer cores when visualizing vitrimer configurations"},
{MANFREDO	           , 0, "" , "manfredo"      , option::Arg::None,     "  --manfredo\n          Used for displaying coarse-grained tetramer configurations. Requires a topology file"},
{ICO     	           , 0, "" , "ico"           , option::Arg::None,     "  --ico\n               Used for displaying icosahedra. Requires a topology file"},
{NATHAN 	           , 0, "n", "nathan"        , option::Arg::Required, "  --nathan, -n size_ratio\n          Used for displaying Nathan-related configurations. Requires a topology file. Expects a numerical value indicating the colloid-to-polymer size ratio"},
{PATCHY 	           , 0, "p", "patchy"        , option::Arg::Required, "  --patchy, -p delta,cosmax,N_A[,N_B]\n          Assumes a patchy configuration, as generated by oxDNA. Requires a topology file. Expects a comma-separated list of parameters (radial and angular widths, number of patches on species A and, optionally, of species B)"},
{DRAW_OUTLINES         , 0, "u", "outlines"      , option::Arg::None,     "  --outlines, -u\n          Draw outlines around objects. It does not work for every object"},
{RESOLUTION            , 0, "r", "resolution"    , option::Arg::Required, "  --resolution, -r initial_resolution\n          Set the initial resolution of the objects. The default is 15"},
{CONFS_TO_SKIP         , 0, "c", "confs-to-skip" , option::Arg::Required, "  --confs-to-skip, -c skip_n_confs\n          Number of configurations that should be skipped every time the user chooses to change the current configuration by using '+' or '-'"},
{COLORS_FROM           , 0, "" , "colors-from"   , option::Arg::Required, "  --colors-from=<file>\n          Files to load the colors from"},
{GROUPS_FROM           , 0, "" , "groups-from"   , option::Arg::Required, "  --groups-from=<file>\n          Files to load the groups from"},
{RBC                   , 0, "" , "rbc"           , option::Arg::None,     "  --rbc\n          Assume an RBC file"},
{BOX                   , 0, "" , "box"           , option::Arg::Required, "  --box=Lx,Ly,Lz\n          Set the lengths of the box sides, overriding the values found in the input files"},
{LEVY		           , 0, "" , "levy"  		 , option::Arg::None,     "  --levy\n          Assume Levy configurations (requires a topology file)"},
{TEP		    	   , 0, "T", "tep"  		 , option::Arg::None,     "  --tep\n          Assume TEP configurations (requires a topology file)"},
{TEP_THRESHOLD         , 0, "" , "tep_t"  		 , option::Arg::Required, "  --tep_t\n          Threshold for the colouring of TEP beads (defaults to 0.98)"},
{OPACITY               , 0, "" , "opacity"		 , option::Arg::Required, "  --opacity\n          If given, the particles indicated in the visibility file will not be hidden but assigned the value of opacity provided"},
{BASE_COLOR_AS_BACKBONE, 0, "" , "bcab"  		 , option::Arg::None,     "  --bcab\n          Give DNA bases the same color as their respective backbones (bcab == Base Color As Backbone)"},
{BASE_COLOR_DRUMS      , 0, "" , "drums"  		 , option::Arg::None,     "  --drums\n          Color-code DNA bases depending on chemical identity, according to the DRuMS color scheme: adenine is blue, guanine is green, cytosine is red, thymine is yellow, uracil is orange."},
{ACTION_FILE		   , 0, "a", "actions-from"	 , option::Arg::Required, "  --actions-from, -a action_file\n          A file containing the list of actions that will be performed on the single configurations. Each action will effectively become a new configuration. '+' and '-' can be used to navigate back and forth actions"},
{ASHELL		    	   , 0, "A", "ashell"  		 , option::Arg::None,     "  --ashell, -A\n          Assume ashell configurations (requires a topology file)"},
{POVRAY_SHADOWS    	   , 0, "" , "povray-shadows", option::Arg::None,     "  --povray-shadows\n          Let povray-generated objects cast shadows"},
{VERSION			   , 0, "" , "version"       , option::Arg::None,     "  --version\n          Print the version and exit"},
{0,0,0,0,0,0}
};

char key_bindings[] = "Keyboard and Mouse Bindings:\n"
		"  +                    show the next configuration\n"
		"  -                    show the previous configuration\n"
		"  F1, ..., F8          toggle light number 1, ..., 8\n"
		"  P                    print povray output. Redirect to the file given by the --output option or to an automatically generated name\n"
#ifdef ENABLE_PNG_EXPORT
		"  ctrl+p               export the current view in PNG format\n"
#endif
		"  a(A)                 increase (decrease) ambient light\n"
		"  b                    hide/show the box\n"
		"  c                    load the initial (or stored) camera state\n"
		"  C                    save the current camera state\n"
		"  d(D)                 increase (decrease) diffusive light\n"
		"  f(F)                 increase (decrease) the field of view\n"
		"  h                    hide selected particles\n"
		"  i                    show/hide printing of the fps counter and other useful debug information\n"
		"  k                    show/hide the axes (3 arrows: red -> x axis, green -> y axis, blue -> z axis)\n"
		"  l                    show/hide labels\n"
		"  number               select particles in the number-th control group\n"
		"  p                    change the projection from perspective to orthographic (and viceversa)\n"
		"  page down            decrease the level of detail of the objects\n"
		"  page up              increase the level of detail of the objects\n"
		"  s                    show all the particles"
		"  x(X), y(Y), z(Z)     move all the particles in the x, y, or z positive (negative) direction\n"
		"  ctrl+x(X), ctrl+y(Y) rotate the scene counterclockwise (clockwise) with respect to the vertical or horizontal axis\n"
		"  u                    dump the cogli1 state to a .cpy file that can be loaded back in cogli1 by using the --load command option\n"
		"  q(Q)                 zoom in (out) (pressing Ctrl at the same time increases zoom speed by a factor 5)\n"
		"  v                    centre the configuration's centre of mass\n"
		"  ctrl+w               select all particles\n"
		"  ctrl+shift+w         invert selection\n"
		"  ctrl+number          save selected particles in the number-th control group\n"
		"  ctrl+click           select the particle below the cursor\n"
		"  shift+click          print the id of the particle below the cursor\n"
		"  x(X)                 move particles towards positive (negative) x\n"
		"  y(Y)                 move particles towards positive (negative) y\n"
		"  z(Z)                 move particles towards positive (negative) z\n";

int main(int argc, char *argv[]) {
	if(argc > 0) {
		argc--;
		argv++;
	}

	option::Stats stats(usage, argc, argv);
	option::Option *options = new option::Option[stats.options_max];
	option::Option *buffer = new option::Option[stats.buffer_max];
	option::Parser parser(usage, argc, argv, options, buffer);

	if(parser.error()) return 1;

	if(options[HELP] || argc == 0) {
		option::printUsage(std::cout, usage);
		cout << endl;
		cout << key_bindings;
		return 0;
	}

	if(options[VERSION]) {
		cout << "cogli2 " << CODE_VERSION << " by L. Rovigatti and F. Romano" << endl;
		return 0;
	}

	if(options[DEBUG]) Logging::debug = true;

	vector<option::Option> v_options;
	for(unsigned int i = 0; i < stats.options_max; i++) {
		v_options.push_back(options[i]);
	}
	Cogli1 c1(parser, options);

	if(options[ONLY_POV]) {
		c1.print_all_pov();
	}
	else {
		c1.start_ogl();
	}

	delete[] options;
	delete[] buffer;

	return 0;
}
